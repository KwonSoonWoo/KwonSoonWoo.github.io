---
layout: post
title: (Cs with python)-메모리(가상메모리와 페이징)
category: 컴퓨터 공학
tags:
  - 컴퓨터 공학
  - 컴퓨터사이언스 부트캠프 with 파이썬
  - 메모리
  - 가상메모리
  - 페이징
  - MMU(Memory Management Unit)
  - 페이지 프레임
  - 페이지 테이블
  - 요구 페이징
  - 페이지 폴트
  - 변환 색인 버퍼
---


> [컴퓨터사이언스 부트캠프 with 파이썬](http://www.yes24.com/24/goods/58552941) 책을 공부하며 정리한 포스팅입니다.
>
> 개인 공부후 정리용으로 남기는 포스팅으로 내용상에 오류가 있을수 있습니다.
>
> 예제 코드는 [Computer-Science](https://github.com/KwonSoonWoo/Computer-Science) 를 통해 실습하고 있습니다.

---

### 핵심개념

- 가상 메모리(virtual memory)
- 페이징(paging)
- MMU(Memory Management Unit)
- 페이지 프레임
- 페이지 테이블
- 요구 페이징
- 페이지 폴트
- 변환 색인 버퍼

---

### 가상 메모리(virtual memory)

- 메인 메모리를 확장하기 위해 하드디스크의 일정 부분인 페이지 파일(page file)을 메인 메모리처럼 사용하는것을 말한다.
  - 물리 메모리(physical memory) = 메인 메모리(RAM) + 페이지 파일
- 페이징(paging)기법은 가상 메모리 관리 기법중 하나

---

### MMU(Memory Management Unit)

- 논리 주소를 물리 주소로 변환해 메인 메모리를 사용해야 할때 필요한 하드웨어
  - **논리 주소(logical address)** - 가상 주소 공간의 메모리 주소
  - **물리 주소(physical address)** - 메인 메모리의 메모리 주소

---

### 페이징(Paging)

- 가상 주소 공간과 메인 메모리를 일정한 크기로 나누어 다룬다
- **페이지(page)** - 가상 주소 공간을 일정한 크기로 쪼갤때 쪼개진 한 부분.
  - 페이지 크기는 시스템마다 다르지만 보통 1~8KB, 32비트 시스템에서는 4KB(4096바이트)
- 가상 주소 공간에는 페이지가 몇 개 있을까?
  - 페이지 개수 = 가상 주소 공간 크기 / 페이지 크기
  -                     = 2^32(4G) / 2^12(4K)
  -                     = 2^20 = 1,048,576(1M)
- 페이지 개수가 2^20개 이므로 페이지에 숫자를 매기려면 2^20의 수가 필요.
- 이를 2진수로 표현하려면 비트가 20개 필요
  - **페이지 넘버(page number)** - 페이지 순서를 나타내는 비트
  - 여기서는 **VPN(Virtual Page Number)**라고 부름.
- 페이지 크기가 4KB일때 페이지 안에 있는 바이트 하나를 가리키려면 비트가 12개 필요.
  - **오프셋(offset)** - 페이지 안에서 특정 바이트를 가리키는 비트
  - 페이지 넘버가 가리키는 페이지의 첫 주소부터 실제 가리키는 주소까지의 거리
- **논리 주소(logical address)** - 페이지 넘버 + 오프셋
  - 위 논리 주소는 CPU가 요청하는 주소로 [프로그램 카운터](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EC%B9%B4%EC%9A%B4%ED%84%B0)에 저장된 값

**10진수로 예시**

```
- 가상 주소 공간: 2,000 바이트
- 페이지 크기: 100바이트
- 프로그램 카운터 값: 234
- 페이지 개수: 20(2,000/100)
- 오프셋: 두 자릿수 10진수(0~99)
```

위와 같다면 전체 2,000바이트에서 페이지 넘버는 어떻게 될까?

```
- 0~99바이트: 0
- 100~199바이트: 1
- 200~299바이트: 2
- 300~399바이트: 3
(중략)
- 1900~1999바이트: 19
```

- 백의 자리 수가 페이지 넘버와 같다.
- 프로그램 카운터 값: 234는 페이지 넘버가 2 / 오프셋이 34라는 의미로 234번째 바이트를 가리킴

---

### 페이지 프레임(page frame)

- **페이지 프레임(page frame)** - 메인 메모리를 쪼갠 부분 하나.
- 메인 메모리의 프레임 = 가상 주소 공간의 페이지의 크기
  - 실제로 존재하지 않는 페이지를 실제 존재하는 프레임에 할당하기 위해서
- **프레임 넘버(frame number)**
  - 프레임 순서를 나타내는 비트
  - 여기서는 **PPN(Physical Page Number)**라고 부름

---

### 페이지 테이블(page table)

- **페이지 테이블(page table)** - 프로세스의 페이지 넘버, 상응하는 프레임 넘버, 상태 등을 저장하는 테이블
- 메인 메모리에 저장, CPU에는 페이지 테이블의 시작 주소(PTBA)를 가리키는 PTBR이라는 레지스터가 있음.
  - **PTBA** - Page Table Base Address
  - **PTBR** - Page Table Base Register

![페이지 테이블](/assets/memory/페이지테이블.png)



- **유효 비트(valid bit)** - 프레임이 실제 메인 메로이에 있는지 아니면 하드디스크에 있는지를 나타냄.
  - 프레임이 메인 메모리에 존재하면 유효 비트는 1, 존재하지 않으면 0

---

### 요구 페이징(demand paging)

- 프로세스를 실행할 때 모든 페이지를 프레임에 매핑하는게 아니라 필요한 페이지만 메인 메모리에 올려 실행하는 것.
- 프리페어링(preparing)
  - 프로세스가 처음 실행될 때 페이지 테이블을 메인 메모리에 만들고 실행에 필요할 것 같은 페이지만 먼저 프레임에 매핑

---

### 페이지 폴트(page fault)

- CPU가 요청한 페이지가 메인 메모리에 없을 때 발생
- 페이지 폴트가 발생하면 해당 페이지를 하드디스크에서 가져와 빈 프레임에 할당하면 됨
- 빈 프레임이 없다면?
  - 페이지 교체 알고리즘에 의해 메모리에 있는 페이지를 하드디스크로 내리고 요청된 페이지를 메인 메모리로 올림
  - **희생 페이지(victim page)** - 하드디스크로 내려지는 페이지
  - **페이지-아웃(page-out)** - 페이지를 메인 메모리에서 하드디스크로 내리는 것.
  - **페이지-인(page-in)** - 하드디스크에서 메인 메모리로 올리는 것.
- 페이지 폴트가 자주 일어나면 프로그램 성능이 상당히 떨어짐.
- 그렇기 때문에 지역성을 고려하면서 프로그래밍을 해야한다.

---

### 변환 색인 버퍼(Translation Lookaside Buffer, TLB)

- 주소 변환 속도를 높이기 위한 일종의 캐시
- 최근에 사용된 페이지 테이블의 일부가 저장되어 있다.
- MMU가 페이지 테이블에서 프레임 넘버를 읽어 와야 할 때 먼저 TLB에 해당 항목이 있는지 확인.
  - TLB 히트 - TLB에 해당 항목이 있는 경우
  - TLB 미스 - TLB에 해당 항목이 없는 경우

---

### Reference

> [프로그램 카운터-위키백과](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EC%B9%B4%EC%9A%B4%ED%84%B0)
>
> [더북](https://thebook.io/006950/ch09/06/05/)